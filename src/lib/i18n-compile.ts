import { debug } from 'loglevel';
import { parse } from 'properties';
import { join } from 'path';
import { camelCase, uniqBy } from 'lodash';
import stringifyObject from 'stringify-object';
import { readFileAsync, outputFileAsync, removeAsync } from 'fs-extra-promise';
import { concatLanguages, isMatchingLocaleOrLanguage } from '../lib/i18n';
import { project, I18nConfig } from '../project';

const parser = require('intl-messageformat-parser');

const GENERATED_WARNING = '// this file was generated by @mercateo/ws - do not modify it manually';

const stringifyObjectOptions = {
  indent: '  '
};

interface TranslationMap {
  [key: string]: string;
}

interface AstMap {
  [key: string]: any;
}

interface Translation {
  locale: string;
  data: TranslationMap;
}

interface GroupedTranslation {
  locale: string;
  translations: Translation[];
}

interface ParsedTranslation {
  locale: string;
  data: TranslationMap;
  asts: AstMap;
}

function camelCaseKeys(data) {
  return Object.keys(data).reduce((acc, key) => {
    acc[camelCase(key)] = data[key];
    return acc;
  }, {});
}

async function readTranslation(locale: string, feature: string): Promise<Translation> {
  const readPath = join(process.cwd(), project.ws.i18n!.dir, feature, `${locale}.properties`);

  debug(`Read from ${readPath}.`);

  const translation: Translation = await readFileAsync(readPath, 'utf8')
    .then(parse)
    .catch(err => {
      if (err.code === 'ENOENT') {
        // translations can be "empty"
        return {};
      } else {
        throw err;
      }
    })
    .then(camelCaseKeys)
    .then(data => ({ data, locale }));

  return translation;
}

function hasArguments(ast) {
 return ast.elements && ast.elements.length && ast.elements.filter(element => element.type === 'argumentElement').length;
}

function getArgumentTypes(ast) {
  const keyTypePairs = uniqBy(
    ast.elements
    .filter(element => element.type === 'argumentElement')
    .map(element => ({
      key: element.id,
      type:
        (element.format && element.format.type === 'pluralFormat')
          ? 'number'
        : (element.format && element.format.type === 'selectFormat')
          ? element.format.options.map(({ selector }) => selector === 'other' ? 'string' : `'${selector}'`).join(' | ')
          : 'string'
    })),
    'key');

  if (keyTypePairs.length) {
    return `{ ${keyTypePairs.map(({ key, type }) => `${key}: ${type}`).join(', ')} }`;
  } else {
    return '';
  }
}

function getArgument(ast, hasTypes) {
  if (hasArguments(ast)) {
    if (hasTypes) {
      return `data${getArgumentTypes(ast)}`;
    } else {
      return 'data';
    }
  } else {
    return '';
  }
}

function getDocumentation(translations: ParsedTranslation[], key: string) {
  return `
/**${translations.map(translation => `
 * \`${translation.locale}\`: ${translation.data[key]}` ).join('')}
 */`;
}

function indent(indentation: string, text: string) {
  return text.split('\n').join(`\n${indentation}`);
}

function writeTranslation(translations: ParsedTranslation[]) {
  const filename = join(project.ws.srcDir, project.ws.i18n!.dir, `index.${project.ws.entryExtension}`);
  const hasTypes = project.ws.entryExtension !== 'js';
  const defaultTranslation = translations[0];
  const keys = Object.keys(defaultTranslation.data);
  const optReturnType = hasTypes ? ': string' : '';
  const optAnyType = hasTypes ? ': any' : '';

  const data =
`${GENERATED_WARNING}
const IntlMessageFormat = require('intl-messageformat');
const INTL_LOCALE = process.env.INTL_LOCALE;

const cachedMessages: { [s: string]: any } = {};
${keys.map(key =>
`${getDocumentation(translations, key)}
export const ${key} = (${getArgument(defaultTranslation.asts[key], hasTypes)})${optReturnType} => {
  if (!cachedMessages['${key}']) {
    let ast${optAnyType};
${translations.map(translation => `
    if (process.env.LOCALE === '${translation.locale}') {
      ast = ${indent('      ', stringifyObject(translation.asts[key], stringifyObjectOptions))};
    }`).join('\n')}

    if (!ast) {
      console.warn('Cannot find translation for "${key}".');
      return '<${key}>';
    }

    cachedMessages['${key}'] = new IntlMessageFormat(ast, INTL_LOCALE);
  }

  return cachedMessages['${key}'].format(${hasArguments(defaultTranslation.asts[key]) ? 'data' : ''});
};
`).join('')}
`;

  return outputFileAsync(filename, data);
}

export async function compileI18n() {
  // at this place we know i18n config is set, no need for null checks
  const i18n = project.ws.i18n as I18nConfig;

  const features = i18n.features || [ '' ];
  const locales = i18n.locales;
  const localesAndLanguages = concatLanguages(locales);

  const readPromises: Promise<Translation>[] = [];
  features.forEach(feature => localesAndLanguages.forEach(localeOrLanguage => {
    readPromises.push(readTranslation(localeOrLanguage, feature));
  }));
  const translations: Translation[] = await Promise.all(readPromises);

  const groupedTranslations: GroupedTranslation[] = locales.map(locale => ({
    locale,
    translations: translations.filter(translation => isMatchingLocaleOrLanguage(translation.locale, locale))
  }));

  const mergedTranslations: Translation[] = groupedTranslations.map(({ locale, translations }) => ({
    locale,
    data: translations.reverse().reduce((acc, translation) => Object.assign(acc, translation.data), {} as TranslationMap)
  }));

  const parsedTranslations: ParsedTranslation[] = mergedTranslations.map(translation => {
    const asts = {};
    Object.keys(translation.data).forEach(key => {
      const ast = parser.parse(translation.data[key]);
      asts[key] = ast;
    });
    return Object.assign({ asts }, translation);
  });

  await removeAsync(join(project.ws.srcDir, i18n.dir));
  await writeTranslation(parsedTranslations);
};
