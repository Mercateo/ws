import { join } from 'path';
import { uniqBy } from 'lodash';
import stringifyObject from 'stringify-object';
import { outputFileAsync, removeAsync } from 'fs-extra-promise';
import { getTranslations, ParsedTranslation } from './get-translations';
import { toIntlLocale } from '../intl';
import { project, I18nConfig } from '../../project';

interface KeyTypePair {
  key: string;
  type: string;
}

const GENERATED_WARNING =
  '// this file was generated by @mercateo/ws - do not modify it manually';

const stringifyObjectOptions = {
  indent: '  '
};

function hasArguments(ast: any) {
  if (!ast || !ast.elements) {
    return false;
  }

  return collectArgumentsRecursive(ast).length !== 0;
}

function collectArgumentsRecursive(ast: any): KeyTypePair[] {
  let pairs: KeyTypePair[] = [];

  if (!ast.elements) {
    return pairs;
  }

  pairs = ast.elements
    .filter((element: any) => element.type === 'argumentElement')
    .map((element: any): KeyTypePair => ({
      key: element.id,
      type:
        element.format && element.format.type === 'pluralFormat'
          ? 'number'
          : element.format && element.format.type === 'selectFormat'
            ? element.format.options
                .map(
                  ({ selector }: any) =>
                    selector === 'other' ? 'string' : `'${selector}'`
                )
                .join(' | ')
            : 'string'
    }));

  const elements: KeyTypePair[][][] = ast.elements
    .filter((element: any) => element.type === 'argumentElement')
    .map((element: any): KeyTypePair[][] => {
      if (element.format && element.format.options) {
        return element.format.options.map((option: any): KeyTypePair[] => {
          if (option.value) {
            return collectArgumentsRecursive(option.value);
          }

          return [];
        });
      }

      return [];
    });

  elements.forEach(element => {
    element.forEach(option => {
      pairs = pairs.concat(option);
    });
  });

  return uniqBy(pairs, 'key');
}

function getArgumentTypes(ast: any) {
  const keyTypePairs: KeyTypePair[] = collectArgumentsRecursive(ast);

  if (keyTypePairs.length) {
    return `{ ${keyTypePairs
      .map(({ key, type }) => `${key}: ${type}`)
      .join(', ')} }`;
  } else {
    return '';
  }
}

function getDocumentation(translations: ParsedTranslation[], key: string) {
  return `
/**${translations
    .map(
      translation => `
 * \`${translation.locale}\`: ${translation.data[key]}`
    )
    .join('')}
 */`;
}

function indent(indentation: string, text: string) {
  return text.split('\n').join(`\n${indentation}`);
}

async function writeTranslation(
  defaultTranslation: ParsedTranslation,
  translation: ParsedTranslation
) {
  const filename = join(project.ws.i18n!.distDir, `${translation.locale}.js`);
  const keys = Object.keys(defaultTranslation.data);
  const intlLocale = await toIntlLocale(translation.locale);

  const data = `${GENERATED_WARNING}
var IntlMessageFormat = require('intl-messageformat');
// use intl polyfill for IE 10 and Safari 9
require('intl');
require('intl/locale-data/jsonp/${intlLocale}');

module.exports.LOCALE = '${translation.locale}';
module.exports.INTL_LOCALE = '${intlLocale}';
module.exports.LANGUAGE_CODE = '${translation.locale.split('_')[0]}';
module.exports.COUNTRY_CODE = '${translation.locale.split('_')[1]}';

var cachedMessages = {};
${keys
    .map(
      key => `
module.exports['${key}'] = function(${hasArguments(translation.asts[key])
        ? 'data'
        : ''}) {${translation.asts[key]
        ? `
  if (!cachedMessages['${key}']) {
    var ast = ${indent(
      '    ',
      stringifyObject(translation.asts[key], stringifyObjectOptions)
    )};
    cachedMessages['${key}'] = new IntlMessageFormat(ast, '${intlLocale}');
  }

  return cachedMessages['${key}'].format(${hasArguments(translation.asts[key])
            ? 'data'
            : ''});`
        : `return 'Missing key "${key}".';`}
};
`
    )
    .join('')}
`;

  return outputFileAsync(filename, data);
}

function writeDeclaration(translations: ParsedTranslation[]) {
  const filename = join(project.ws.i18n!.distDir, 'index.d.ts');
  const defaultTranslation = translations[0];
  const keys = Object.keys(defaultTranslation.data);

  const data = `${GENERATED_WARNING}
declare interface I18N {
  /**
   * Your locale in the format \`de_DE\`, \`en_US\`, etc.
   */
  LOCALE: string;

  /**
   * Your locale in the format \`de-DE\`, \`en-US\`, etc.
   */
  INTL_LOCALE: string;

  /**
   * Your language code in the format \`de\`, \`en\`, etc.
   */
  LANGUAGE_CODE: string;

  /**
   * Your country code in the format \`DE\`, \`US\`, etc.
   */
  COUNTRY_CODE: string;${keys
    .map(
      key =>
        `
${getDocumentation(translations, key)}
  ${key}: (${hasArguments(defaultTranslation.asts[key])
          ? `data: ${getArgumentTypes(defaultTranslation.asts[key])}`
          : ''}) => string,`
    )
    .join('\n')}
}
`;

  return outputFileAsync(filename, data);
}

export async function compile() {
  // at this place we know i18n config is set, no need for null checks
  const i18n = project.ws.i18n as I18nConfig;
  const parsedTranslations: Array<ParsedTranslation> = await getTranslations();

  await removeAsync(i18n.distDir);
  await Promise.all(
    parsedTranslations.map(parsedTranslation =>
      writeTranslation(parsedTranslations[0], parsedTranslation)
    )
  );

  if (project.ws.entryExtension !== 'js') {
    await writeDeclaration(parsedTranslations);
  }
}
