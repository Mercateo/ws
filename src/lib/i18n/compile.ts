import { join } from 'path';
import { uniqBy } from 'lodash';
import stringifyObject from 'stringify-object';
import { outputFileAsync, removeAsync } from 'fs-extra-promise';
import { getTranslations, ParsedTranslation } from './get-translations';
import { toIntlLocale } from '../intl';
import { project, I18nConfig } from '../../project';

const GENERATED_WARNING = '// this file was generated by @mercateo/ws - do not modify it manually';

const stringifyObjectOptions = {
  indent: '  '
};

function hasArguments(ast: any) {
 return ast && ast.elements && ast.elements.length && ast.elements.filter((element: any) => element.type === 'argumentElement').length;
}

function getArgumentTypes(ast: any) {
  const keyTypePairs = uniqBy(
    ast.elements
    .filter((element: any) => element.type === 'argumentElement')
    .map((element: any) => ({
      key: element.id,
      type:
        (element.format && element.format.type === 'pluralFormat')
          ? 'number'
        : (element.format && element.format.type === 'selectFormat')
          ? element.format.options.map(({ selector }: any) => selector === 'other' ? 'string' : `'${selector}'`).join(' | ')
          : 'string'
    })),
    'key');

  if (keyTypePairs.length) {
    return `{ ${keyTypePairs.map(({ key, type }) => `${key}: ${type}`).join(', ')} }`;
  } else {
    return '';
  }
}

function getDocumentation(translations: ParsedTranslation[], key: string) {
  return `
/**${translations.map(translation => `
 * \`${translation.locale}\`: ${translation.data[key]}` ).join('')}
 */`;
}

function indent(indentation: string, text: string) {
  return text.split('\n').join(`\n${indentation}`);
}

async function writeTranslation(defaultTranslation: ParsedTranslation, translation: ParsedTranslation) {
  const filename = join(project.ws.i18n!.distDir, `${translation.locale}.js`);
  const keys = Object.keys(defaultTranslation.data);
  const intlLocale = await toIntlLocale(translation.locale);

  const data =
    `${GENERATED_WARNING}
var IntlMessageFormat = require('intl-messageformat');
// use intl polyfill for IE 10 and Safari 9
require('intl');
require('intl/locale-data/jsonp/${intlLocale}');

var myModule = {};
module.exports.LOCALE = myModule.LOCALE = '${translation.locale}';
module.exports.INTL_LOCALE = myModule.INTL_LOCALE = '${intlLocale}';
module.exports.LANGUAGE_CODE = myModule.LANGUAGE_CODE = '${translation.locale.split('_')[0]}';
module.exports.COUNTRY_CODE = myModule.COUNTRY_CODE = '${translation.locale.split('_')[1]}';

var cachedMessages = {};
${keys.map(key => `
module.exports.${key} = myModule.${key} = function(${hasArguments(translation.asts[key]) ? 'data' : ''}) {${translation.asts[key] ? `
  if (!cachedMessages.${key}) {
    var ast = ${indent('    ', stringifyObject(translation.asts[key], stringifyObjectOptions))};
    cachedMessages.${key} = new IntlMessageFormat(ast, myModule.INTL_LOCALE);
  }

  return cachedMessages.${key}.format(${hasArguments(translation.asts[key]) ? 'data' : ''});`
  : `return 'Missing key "${key}".';`}
};
`).join('')}

// sadly this re-export with our custom module name is needed
// see https://github.com/donaldpipowitch/webpack-i18n-example
module.exports['mercateo/i18n'] = myModule;
`;

  return outputFileAsync(filename, data);
}

async function writeTranslationUnit(translation: ParsedTranslation) {
  const filename = join(project.ws.i18n!.distDir, `unit.js`);
  const keys = Object.keys(translation.data);
  const intlLocale = await toIntlLocale(translation.locale);

  const data =
    `${GENERATED_WARNING}
const IntlMessageFormat = require('intl-messageformat');
// use intl polyfill for IE 10 and Safari 9
require('intl');
require('intl/locale-data/jsonp/${intlLocale}');

export const LOCALE = '${translation.locale}';
export const INTL_LOCALE = '${intlLocale}';
export const LANGUAGE_CODE = '${translation.locale.split('_')[0]}';
export const COUNTRY_CODE = '${translation.locale.split('_')[1]}';

const cachedMessages = {};
${keys.map(key => `
export const ${key} = (${hasArguments(translation.asts[key]) ? 'data' : ''}) => {${translation.asts[key] ? `
    if (!cachedMessages['${key}']) {
    const ast = ${indent('    ', stringifyObject(translation.asts[key], stringifyObjectOptions))};
    cachedMessages['${key}'] = new IntlMessageFormat(ast, INTL_LOCALE);
  }

  return cachedMessages['${key}'].format(${hasArguments(translation.asts[key]) ? 'data' : ''});`
  : `return 'Missing key "${key}".'`}
};
`).join('')}
`;

  return outputFileAsync(filename, data);
}

function writeDeclaration(translations: ParsedTranslation[]) {
  const filename = join(project.ws.i18n!.distDir, 'index.d.ts');
  const defaultTranslation = translations[0];
  const keys = Object.keys(defaultTranslation.data);

  const data =
    `${GENERATED_WARNING}
declare module '${project.ws.i18n!.module}' {
  /**
   * Your locale in the format \`de_DE\`, \`en_US\`, etc.
   */
  export const LOCALE: string;

  /**
   * Your locale in the format \`de-DE\`, \`en-US\`, etc.
   */
  export const INTL_LOCALE: string;

  /**
   * Your language code in the format \`de\`, \`en\`, etc.
   */
  export const LANGUAGE_CODE: string;

  /**
   * Your country code in the format \`DE\`, \`US\`, etc.
   */
  export const COUNTRY_CODE: string;${keys.map(key =>
      `
${getDocumentation(translations, key)}
  export function ${key}(${hasArguments(defaultTranslation.asts[key]) ? `data: ${getArgumentTypes(defaultTranslation.asts[key])}` : ''}): string;`).join('\n')}
}
`;

  return outputFileAsync(filename, data);
}

export async function compile() {
  // at this place we know i18n config is set, no need for null checks
  const i18n = project.ws.i18n as I18nConfig;
  const parsedTranslations: Array<ParsedTranslation> = await getTranslations();

  await removeAsync(i18n.distDir);
  await Promise.all(parsedTranslations.map(parsedTranslation => writeTranslation(parsedTranslations[0], parsedTranslation)));
  await writeTranslationUnit(parsedTranslations[0]);

  if (project.ws.entryExtension !== 'js') {
    await writeDeclaration(parsedTranslations);
  }
}
